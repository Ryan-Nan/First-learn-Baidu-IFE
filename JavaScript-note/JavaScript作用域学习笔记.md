# JavaScript作用域学习笔记 

## 全局和局部作用域
作用域（scope），翻译意思是范围。这很好理解，变量和函数可访问的范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。
### 全局作用域（Global Scope）
在代码中任何地方都能访问到的对象称为全局作用域。

1、最外层函数和在最外层函数外面定义的变量拥有全局作用域；

2、所有末定义直接赋值的变量自动声明为拥有全局作用域；

3、所有window对象的属性拥有全局作用域。
一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。
### 局部作用域 （Local Scope）
和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域

代码如下：

    var a = 1;
    //全局作用域，只能访问全局变量，也就是a变量
    function A(){
        var b = 2;
        //A函数的局部作用域，可以访问到a，b变量，但是访问不到c变量
        function B(){
            //B函数局部作用域，可以访问到a，b，c变量
            var c = 3;
             d = 4;//d是全局作用域，因为没有定义直接赋值的变量
        }
    }

注：如果确定要定义为局部变量，那么千万不要忘记使用 var 操作符哦。 

在函数中使用var操作符定义一个变量，那么当这个函数执行完毕之后，这个变量也会被销毁（也有的情况下不会，比如闭包，后面会说明），而全局变量会一直存在。所以在我们写代码时，尽量少的使用全局变量，滥用全局变量，简直就是一个会令人恶心的习惯，因为它会带来很多不必要的麻烦。


* 1：变量过多，命名麻烦
* 2：局部变量，忘记使用var定义，修改了全局变量，这样的错误对于代码的维护简直是噩梦
* 3：全局变量会在页面卸载前一直存在，损耗不必要的内存。

##  作用域链（Scope Chain）
引自Javascript高级程序设计（第三版）（P73）：当代码在一个环境中执行时，会创建变量对象的的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是一个函数，则将其活动对象作为变量对象。

每一个函数都有自己的执行环境，当执行流进一个函数时，函数环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个栈也就是作用域链。

上面讲解有点难懂，下面给出了摘自[梦想天空博客-理解 JavaScript 作用域和作用域链](http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html)

在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。

[作用域链](images/Scope Chain.jpg)如下图所示

![作用域链](images/Scope Chain.jpg)

函数add的作用域将会在执行时用到。例如执行如下代码：

        var total = add(5,10);

　　执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行上下文(执行环境)定义了函数执行时的环境。每个运行上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。

　　这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：
　　
![New Scope Chain](images/newScopeChain.jpg)

在函数执行过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。

从作用域链的结构可以看出，在运行上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。如上图所示， 
** 因为全局变量总是存在于运行上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。** 所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。
